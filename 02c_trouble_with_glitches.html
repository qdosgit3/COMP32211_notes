<title>Simulation trouble with glitches</title>

<html>
<head>

<style>
table, th, td {
  border: 1px solid black;
}
</style>

<style>
* {
  box-sizing: border-box;
}

/* Create two equal columns that float next to each other */
.column {
  float: left;
  width: 50%;
  padding: 10px;
}

/* Clear floats after the columns */
.row:after {
  content: "";
  display: table;
  clear: both;
}
</style>

<style>
.inset {
  float: none;
  width: 80%;
  border: 2px outset red;
  background-color: lightgray;
  text-align: center;
}
div.left {text-align:left;}
</style>

<style>
h1 {text-align: center;}
</style>

</head>

<body>

<center>
<p style="color:green">This is a little bonus page which looks at some
  ways of timing control signals, particularly in Verilog simulation.
  Some ways of expressing intent are more robust than others!</p>
</center>

<h1>Simulation and (potential) trouble with glitches</h1>

<h2>The problem</h2>

<p>
A &lsquo;<b>glitch</b>&rsquo; is a short change in the state of a
signal which was not intended as part of a design.  Here
&lsquo;short&rsquo; means significantly less than a clock cycle.  In
an <i>implemented</i> circuit glitches are generated by
signal <i>races</i> through gates; they appear when the logic is
mapped into gates (or similar) either by a designer or &ndash; more
commonly &ndash; by the logic synthesis.<br>
As written in behavioural HDL there is (usually) no delay expressed in
this logic so races don't happen so glitches don't appear.
</p>

<center>
<img src="figures/glitch_create.png" alt="How glitchesmight occur"; width=70%;>
</center>

<p>
Simulation is normally conducted on a behavioural design.  Ideally the
same tests can be applied <i>post-synthesis</i> to the design and
should still run.  This involves &lsquo;<b>extracting</b>&rsquo; the
synthesized netlist and reapplying the tests.  There are now likely to
be glitches on some signals.
</p>

<p>
Glitches are not usually a functional<sup>&dagger;</sup> problem
&ndash; at least in <b>synchronous circuits</b>.  The clocked
registers prevent glitch propagation and the clock period allows the
circuit to &lsquo;settle&rsquo; before proceeding.<br>
<i>Signals should only be regarded as stable and <u>sampled</u> at
  active clock edges.</i>
</p>

<p>
Glitches on general data signals &ndash; such as adder operands
&ndash; rarely pose a problem.  However glitches on <i>control</i>
signals can catch out the unwary.
</p>

<blockquote style="font-size:80%;">
<sup>&dagger;</sup>The added transitions will waste some <i>energy</i>
but that's a problem for a different page.
</blockquote>

<h2>Simulation</h2>

<p>
When driving a Verilog simulation there are different instructions
which can be applied to detect whether something has happened.  Let's
say we want to detect if an operation has finished by checking a
&lsquo;busy&rsquo; signal.
</p>

<blockquote style="font-family: 'Courier New', monospace;">
@ (negedge busy) &hellip;<br>
&nbsp;<br>
wait (!busy);
</blockquote>

<img src="figures/glitch_waits.png" alt="Effects of glitches in
					 simulation"; width=50%; align="right">

<p>
These will both detect a low on the <span style="font-family: 'Courier
New', monospace;">busy</span> signal, as the <i>next</i>
falling <b>transition</b> or the <b>level</b> (including immediately
if there is a &lsquo;low&rsquo; level when executed) but they will
also be passed if there is a glitch which would not be seen in a real
circuit.  Possibly the most likely effect would be the <i>apparent</i>
failure of a formerly working verification test. &#x1F61E;
</p>

<p>
This disappointment can be overcome by <u>synchronising</u> the test
to the clock in the same way as the registers will.  Thus:
</p>

<blockquote style="font-family: 'Courier New', monospace;">
@ (posedge clk) if (!busy) &hellip;<br>
&nbsp;<br>
while (busy) @ (posedge clk) &hellip;
</blockquote>

<p>
the latter assuming that the time is already at a(n active) clock
edge on entry.
</p>

<p>
The figure illustrates the timing where the different statements are
executed (the bottom line is tacitly assumed to be already synchronised
to <span style="font-family: 'Courier New', monospace;">clk</span>,
hence the <span style="color:grey">grey</span> statement).  In each
case the solid <span style="color:blue">blue</span> bars show when
execution of that &lsquo;thread&rsquo; continues.
</p>

<p>
To detect if a signal (or bus) has <i>changed</i>, similar ploys can
be used.
</p>

<blockquote style="font-family: 'Courier New', monospace;">
always @ (posedge clk)<br>
&nbsp; begin<br>
&nbsp; changed &nbsp;<= (data != old_data);<br>
&nbsp; old_data <= data;<br>
&nbsp; end<br>
&nbsp;<br>
always @ (posedge clk)<br>
&nbsp; begin<br>
&nbsp; busy_end <= (!busy && was_busy); &nbsp; // Makes a pulse<br>
&nbsp; was_busy <= busy;<br>
&nbsp; end<br>
</blockquote>

<p>
By following this (type of) strategy you can make your tests more
robust.
</p>

<hr>

<p><a href="02_simulation.html#index">Back to Simulation</a></p>
<p><a href="02f_simulation_time.html">Back</a> to simulation time</p>

<p><a href="contents.html">Up to Contents</a></p>

<hr><hr>

</body>
